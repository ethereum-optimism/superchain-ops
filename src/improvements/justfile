export TASK_PATH := invocation_directory()

###################################
## Create a new template or task ##
## e.g. just new [template|task] ##
###################################
new COMMAND="" TASK_TYPE="":
    #!/usr/bin/env bash
    set -euo pipefail

    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    show_usage() {
        echo
        echo "Usage: just new [template|task]"
        echo "Available commands:"
        echo "  • template  - Create a new template"
        echo "  • task      - Create a new task"
        echo
    }

    show_task_types() {
        echo
        echo "Available task types:"
        echo "  • l2taskbase - 'L2TaskBase' task type, these tasks require a superchain address registry and can iterate over multiple L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/test/tasks/mock/template/GasConfigTemplate.sol"
        echo "  • simpletaskbase - 'SimpleTaskBase' task type, these tasks require simple key value registry and are independent of the L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/FinanceTemplate.sol"
        echo "  • opcmtaskbase - 'OPCMTaskBase' task type, these tasks are used to make delegate calls to the Optimism Contracts Manager and are"
        echo "    dependent on the L2 chains and inherit from L2TaskBase"
        echo "    e.g.: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/OPCMUpgradeV200.sol"
        echo
    }

    # shellcheck disable=SC2050
    case "{{COMMAND}}" in
        "")
            echo -e "\n\033[31mError: No command specified\033[0m"
            show_usage
            exit 1
            ;;
        template)
            if [ -z "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: No task type specified\033[0m"
                show_task_types
                exit 1
            fi

            case "$(echo {{TASK_TYPE}} | tr '[:upper:]' '[:lower:]')" in
                l2taskbase)
                    TASK_TYPE="L2TaskBase"
                    ;;
                simpletaskbase)
                    TASK_TYPE="SimpleTaskBase"
                    ;;
                opcmtaskbase)
                    TASK_TYPE="OPCMTaskBase"
                    ;;
                *)
                    echo -e "\n\033[31mError: Invalid task type '{{TASK_TYPE}}'\033[0m"
                    show_task_types
                    exit 1
                    ;;
            esac
            echo -e "\nSelected task type: \033[33m $TASK_TYPE \033[0m"
            ./script/create-template.sh "$TASK_TYPE"
            ;;
        task)
            if [ -n "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: Task type should not be specified for 'task' command\033[0m"
                exit 1
            fi
            ./script/create-task.sh
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m"
            show_usage
            exit 1
            ;;
    esac




#################################################
##                Stack Commands               ##
## e.g. simulate-stack, sign-stack, list-stack ##
#################################################
simulate-stack NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"

    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m    superchain-ops stacked simulation    \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just simulate-stack <network> [task] [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Simulates the execution of tasks in a stacked manner, accounting for dependencies and nested safe architectures."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to simulate on (e.g. 'sep', 'eth')"
        echo
        echo "Optional arguments:"
        echo "  • [task]                       - Specific task to simulate (e.g. '001-task-name')"
        echo "                                   If omitted, simulates all non-terminal tasks for the network"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Examples:"
        echo "  just simulate-stack eth                             # Simulate all tasks for ethereum"
        echo "  just simulate-stack eth 001-example                # Simulate specific task on root safe"
        echo "  just simulate-stack eth 001-example foundation     # Simulate on foundation child safe"
        echo "  just simulate-stack eth 001-example council foundation  # Simulate on nested architecture"
        echo
        echo "Note: Stacked simulation executes all prerequisite non-terminal tasks in dependency order."
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    ETH_RPC_URL=$(just _fetch-rpc-url "{{NETWORK}}")

    echo -e "\n⏳ Stacked Task simulation in progress. This may take a while..."
    if [ -z "{{TASK}}" ]; then
        echo -e "⏳ You are simulating all tasks for network: {{NETWORK}}\n"
        just list-stack {{NETWORK}}
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string)" {{NETWORK}} --ffi --rpc-url $ETH_RPC_URL
    else
        child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
        child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")
        just list-stack {{NETWORK}} {{TASK}}
        
        # Determine which function signature to use based on provided child safes
        if [ "$child_safe_depth_2" != "0x0000000000000000000000000000000000000000" ]; then
            echo -e "⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_2\n"
            forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_2" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
        else
            echo -e "⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_1\n"
            forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
        fi
        
    fi
    echo -e "\n⚠️ Please note: Some Tenderly links may not work when running a stacked simulation. Check out Tenderly's Virtual TestNets as a workaround.⚠️"

sign-stack NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m       superchain-ops sign task          \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just sign-stack <network> <task> [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Signs a task for execution on the specified network and safe architecture."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to sign for (e.g. 'sep', 'eth')"
        echo "  • <task>                       - The task to sign (e.g. '001-task-name')"
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Environment variables:"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo
        echo "Examples:"
        echo "  just sign-stack eth 001-example                          # Sign for root safe only"
        echo "  just sign-stack eth 001-example foundation               # Sign for foundation child safe"
        echo "  just sign-stack eth 001-example council foundation       # Sign for council->foundation nested"
        echo "  HD_PATH=1 just sign-stack eth 001-example                # Sign with HD path 1"
        echo
    }

    if [ -z "{{NETWORK}}" ] || [ -z "{{TASK}}" ]; then
        show_usage
        exit 0
    fi
    
    export SIGNING_MODE_IN_PROGRESS=true # This environment variable is typically used to reduce logging. TODO: Should consolidate this in the future.
    export STACKED_SIGNING_MODE=true # This environment variable is only ever set to true in this sign command. 

    ETH_RPC_URL=$(just --justfile "$root_just_file" _fetch-rpc-url "{{NETWORK}}")
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")

    # We only support signing with ledger for now.
    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
    signer_args=$(just --justfile "$root_just_file" _get-signer-args ${HD_PATH})

    # Determine which function signature to use based on provided child safes
    if [ "$child_safe_depth_2" != "0x0000000000000000000000000000000000000000" ]; then
        echo -e "⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_2\n"
        ${root_dir}/bin/eip712sign ${signer_args} -- \
         forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_2" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
    else
        echo -e "⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_1\n"
        ${root_dir}/bin/eip712sign ${signer_args} -- \
         forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
    fi

list-stack NETWORK="" TASK="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)

    show_usage() {
        echo
        echo "Usage: just list-stack <network> [task]"
        echo "This command will list all the tasks that can be simulated for a given network."
        echo "Available arguments:"
        echo "  • <network> - The network to simulate the stack for (e.g. 'sep', 'eth')"
        echo "  • [task]    - The task to simulate the stack for (e.g. '001-task-name')"
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    if [ -z "{{TASK}}" ]; then
        echo "Listing all tasks for network: {{NETWORK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string)" {{NETWORK}}
    else
        echo "Listing all tasks for network: {{NETWORK}} up to task: {{TASK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string,string)" {{NETWORK}} {{TASK}}
    fi


#  ┌────────────────────┐      
#  │ Child Safe Depth 2 │
#  │ e.g. 'base-council'│
#  └────────────────────┘      
#             │                
#             └─────────────────┬
#                               ▼     
#                           ┌────────────────────┐
#                           │ Child Safe Depth 1 │
#                           │  e.g. 'foundation' │
#                           └────────────────────┘
#                                      │          
#                                      └──────────┬
#                                                 ▼
#                                          ┌─────────────────┐
#                                          │ ProxyAdminOwner │
#                                          └─────────────────┘
########################################
##          Non-Stacked Commands      ##
## e.g. simulate, sign                ##
########################################
simulate CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"

    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m        superchain-ops simulation        \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just simulate <network> <task> [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Simulates a single task execution on the specified network and safe architecture."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to simulate on (e.g. 'sep', 'eth')"
        echo "  • <task>                       - The task to simulate (e.g. '001-task-name')"
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo
        echo "Environment variables:"
        echo "  • SIMULATE_WITHOUT_LEDGER      - If set, uses first safe owner instead of ledger"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo "  • FORK_BLOCK_NUMBER            - Specific block number to fork from (default: latest)"
        echo "                                   Set to -1 to use latest block explicitly"
        echo
        echo "Examples:"
        echo "  just simulate eth 001-example                            # Simulate on root safe"
        echo "  just simulate eth 001-example foundation                 # Simulate on foundation child safe"
        echo "  SIMULATE_WITHOUT_LEDGER=1 just simulate eth 001-example  # Simulate without ledger"
        echo "  HD_PATH=1 just simulate eth 001-example                  # Use HD path 1"
        echo "  FORK_BLOCK_NUMBER=12345 just simulate eth 001-example    # Fork from specific block"
        echo
    }

    # Make sure to set the FETCH_TASKS_TEST_DIR environment variable if we are running a test task. See: fetch-tasks.sh for more details.
    if [[ "$TASK_PATH" == *"test/tasks/example"* ]]; then
        export FETCH_TASKS_TEST_DIR="test/tasks/example"
    fi

    task_name=$(basename "$TASK_PATH")
    network=$(basename "$(dirname "$TASK_PATH")")
    ETH_RPC_URL=$(just _fetch-rpc-url "$network")
    ZERO_ADDRESS="0x0000000000000000000000000000000000000000"

    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
    
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")

    # Get function signature and arguments using helper
    eval "$(just --justfile "$root_just_file" _build-simulator-args "$network" "$TASK_PATH" "{{CHILD_SAFE_NAME_DEPTH_1}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")"
    
    config_path=${TASK_PATH}/config.toml

    # Configure signer for simulation
    if [ -z "$SIMULATE_WITHOUT_LEDGER" ]; then
        signer=$(cast wallet address --ledger --mnemonic-derivation-path "m/44'/60'/${HD_PATH}/0/0")
        echo "Simulating with ledger account: ${signer}"
    else
        # Get the appropriate safe to extract signer from
        if [ "$child_safe_depth_2" != "$ZERO_ADDRESS" ]; then
            safe_for_signer="$child_safe_depth_2"
        elif [ "$child_safe_depth_1" != "$ZERO_ADDRESS" ]; then
            safe_for_signer="$child_safe_depth_1" 
        else
            # Get root safe from task
            safe_for_signer=$(forge script TaskManager --sig "getRootSafe(string)" $config_path --rpc-url $ETH_RPC_URL --json | jq -r '.returns["0"].value')
        fi
        signer=$(cast call ${safe_for_signer} "getOwners()(address[])" -r $ETH_RPC_URL | grep -oE '0x[a-fA-F0-9]{40}' | head -n1)
        echo "Simulating without ledger using first owner from safe ${safe_for_signer}: ${signer}"
    fi
    
    # Get fork block arguments
    fork_block_args=$(just --justfile "$root_just_file" _get-fork-block-args)
    
    echo -e "⏳ You are simulating the task: $task_name for network: '$network' on $target_safe\n"
    forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "$sig" "${args[@]}" --ffi --rpc-url $ETH_RPC_URL --sender ${signer} ${fork_block_args}

sign NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m       superchain-ops sign task          \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just sign <network> <task> [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Signs a task for execution on the specified network and safe architecture."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to sign for (e.g. 'sep', 'eth')"
        echo "  • <task>                       - The task to sign (e.g. '001-task-name')"
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Environment variables:"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo "  • USE_KEYSTORE                 - If set, uses keystore instead of ledger"
        echo
        echo "Examples:"
        echo "  just sign eth 001-example                          # Sign for root safe only"
        echo "  just sign eth 001-example foundation               # Sign for foundation child safe"
        echo "  just sign eth 001-example council foundation       # Sign for council->foundation nested"
        echo "  HD_PATH=1 just sign eth 001-example                # Sign with HD path 1"
        echo "  USE_KEYSTORE=1 just sign eth 001-example           # Sign with keystore"
        echo
    }

    if [ -z "{{NETWORK}}" ] || [ -z "{{TASK}}" ]; then
        show_usage
        exit 0
    fi
    
    export SIGNING_MODE_IN_PROGRESS=true

    ETH_RPC_URL=$(just --justfile "$root_just_file" _fetch-rpc-url "{{NETWORK}}")
    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
    
    # Get function signature and arguments using helper
    eval "$(just --justfile "$root_just_file" _build-simulator-args "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_1}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")"
    
    # Determine which safe to validate signer against
    if [ "$child_safe_depth_2" != "0x0000000000000000000000000000000000000000" ]; then
        target_safe_for_validation="$child_safe_depth_2"
    elif [ "$child_safe_depth_1" != "0x0000000000000000000000000000000000000000" ]; then
        target_safe_for_validation="$child_safe_depth_1"
    else
        # Get root safe from task
        task_path=${root_dir}/src/improvements/tasks/{{NETWORK}}/{{TASK}}/config.toml
        target_safe_for_validation=$(forge script TaskManager --sig "getRootSafe(string)" $task_path --rpc-url $ETH_RPC_URL --json | jq -r '.returns["0"].value')
    fi
    
    # Configure signer (ledger or keystore)
    echo "getting signer address..."
    if [ -z "${USE_KEYSTORE:-}" ]; then
        hdpaths="m/44'/60'/${HD_PATH}'/0/0"
        echo "Using ledger"
        signer=$(cast wallet address --ledger --mnemonic-derivation-path $hdpaths)
        signer_args="--ledger --hd-paths $hdpaths"
    else
        echo "Using keystore"
        signer_private_key=$(just --justfile "$root_just_file" _get-keystore-private-key "{{NETWORK}}" "{{TASK}}")
        signer=$(cast wallet address --private-key ${signer_private_key})
        signer_args="--private-key ${signer_private_key#0x}"
    fi
    echo "Signing with: ${signer}"
    
    # Validate that signer is an owner on the target safe
    echo "Validating signer is an owner on the safe..."
    # forge script TaskManager --rpc-url $ETH_RPC_URL --sig "requireSignerOnSafe(address,address)" $signer $target_safe_for_validation
    
    echo "⏳ Task signing in progress. Some tasks take longer than others..."
    forge build
    ${root_dir}/bin/eip712sign ${signer_args} -- \
     forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "$sig" "${args[@]}" --ffi --rpc-url $ETH_RPC_URL

########################
### Helper functions ###
########################
# not intended for end users
_fetch-rpc-url NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail
    profile="${FOUNDRY_PROFILE:-default}"
    case "{{NETWORK}}" in
      sep)  yq eval ".profile.\"${profile}\".rpc_endpoints.sepolia" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      eth)  yq eval ".profile.\"${profile}\".rpc_endpoints.mainnet" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      *)    echo "Error: Must provide a valid network, '{{NETWORK}}' is not valid." >&2; exit 1 ;;
    esac

# Helper function to fetch the safe address for a given network and task.
[no-cd] 
_fetch-safe TASK_DIR_PATH OWNER_SAFE_NAME:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    safe="0x0000000000000000000000000000000000000000" # Default to zero address for non-nested safes
    if [ -n "{{OWNER_SAFE_NAME}}" ]; then
        safe=$(bash ${root_dir}/src/improvements/script/get-safe.sh "{{TASK_DIR_PATH}}" "{{OWNER_SAFE_NAME}}")
    fi
    echo "${safe}"

# Helper function to get the signer arguments for a given hdPath. We do not need to support signing with keystores.
[no-cd]
_get-signer-args hdPath='0':
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    hdpaths="m/44'/60'/{{hdPath}}'/0/0"
    signer=$(cast wallet address --ledger --mnemonic-derivation-path $hdpaths)
    signer_args="--ledger --hd-paths $hdpaths"
    echo $signer_args

# Helper function to get fork block arguments based on FORK_BLOCK_NUMBER environment variable
[no-cd]
_get-fork-block-args:
    #!/usr/bin/env bash
    set -euo pipefail
    
    # Allow simulating from a specific block by setting FORK_BLOCK_NUMBER environment variable.
    # If not set (or set to -1), default to using the latest block.
    if [ "${FORK_BLOCK_NUMBER:-"-1"}" = "-1" ]; then
        echo ""  # Return empty string for no additional args
    else
        echo "Using fork block number from env: ${FORK_BLOCK_NUMBER}" >&2
        echo "--fork-block-number ${FORK_BLOCK_NUMBER}"
    fi

# Helper function to handle keystore selection and private key extraction
[no-cd]
_get-keystore-private-key NETWORK TASK:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    task_path=${root_dir}/src/improvements/tasks/{{NETWORK}}/{{TASK}}
    
    echo "Enter your foundry keystore path (e.g. ~/.foundry/keystores/sep-test-private-key):" >&2
    keystorePath=$(cd ~/.foundry/keystores/ && fzf --header="Searching your keystore in $PWD" --prompt="Keystore for signing:")
    
    cd ${task_path}
    echo "Keystore path: ${keystorePath}" >&2
    # Build full keystore path
    full_keystore_path="$HOME/.foundry/keystores/${keystorePath}"
    signer_private_key=$(cast wallet pk --keystore ${full_keystore_path})
    sender=$(cast wallet address --private-key ${signer_private_key})
    echo "Signing with the signer: ${sender}" >&2
    if [ -z "${signer_private_key}" ]; then
        echo "Error: Failed to get private key for keystore ${full_keystore_path}" >&2
        exit 1
    fi
    echo "${signer_private_key}"

# Helper function to build simulator function signature and arguments. It's expected that the caller will eval the output.
[no-cd]
_build-simulator-args NETWORK TASK_DIR_PATH CHILD_SAFE_NAME_DEPTH_1 CHILD_SAFE_NAME_DEPTH_2:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    ZERO_ADDRESS="0x0000000000000000000000000000000000000000"
    
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_DIR_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_DIR_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")
    task_name=$(basename "{{TASK_DIR_PATH}}")
    
    # Export child safe addresses for use by caller
    echo "child_safe_depth_1=\"$child_safe_depth_1\""
    echo "child_safe_depth_2=\"$child_safe_depth_2\""
    
    # Build function signature and arguments dynamically
    if [ "$child_safe_depth_2" != "$ZERO_ADDRESS" ]; then
        echo "sig=\"simulate(string,string,address,address)\""
        echo "args=(\"{{NETWORK}}\" \"$task_name\" \"$child_safe_depth_2\" \"$child_safe_depth_1\")"
        echo "target_safe=\"nested safe: $child_safe_depth_2\""
    elif [ "$child_safe_depth_1" != "$ZERO_ADDRESS" ]; then
        echo "sig=\"simulate(string,string,address)\""
        echo "args=(\"{{NETWORK}}\" \"$task_name\" \"$child_safe_depth_1\")"
        echo "target_safe=\"nested safe: $child_safe_depth_1\""
    else 
        echo "sig=\"simulate(string,string)\""
        echo "args=(\"{{NETWORK}}\" \"$task_name\")"
        echo "target_safe=\"default safes\""
    fi



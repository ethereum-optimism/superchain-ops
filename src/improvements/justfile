# Create a new template or task
# e.g. just new [template|task]
new COMMAND="" TASK_TYPE="":
    #!/usr/bin/env bash
    set -euo pipefail

    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    show_usage() {
        echo
        echo "Usage: just new [template|task]"
        echo "Available commands:"
        echo "  • template  - Create a new template"
        echo "  • task      - Create a new task"
        echo
    }

    show_task_types() {
        echo
        echo "Available task types:"
        echo "  • l2taskbase - 'L2TaskBase' task type, these tasks require a superchain address registry and can iterate over multiple L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/test/tasks/mock/template/GasConfigTemplate.sol"
        echo "  • simpletaskbase - 'SimpleTaskBase' task type, these tasks require simple key value registry and are independent of the L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/FinanceTemplate.sol"
        echo "  • opcmtaskbase - 'OPCMTaskBase' task type, these tasks are used to make delegate calls to the Optimism Contracts Manager and are"
        echo "    dependent on the L2 chains and inherit from L2TaskBase"
        echo "    e.g.: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/OPCMUpgradeV200.sol"
        echo
    }

    # shellcheck disable=SC2050
    case "{{COMMAND}}" in
        "")
            echo -e "\n\033[31mError: No command specified\033[0m"
            show_usage
            exit 1
            ;;
        template)
            if [ -z "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: No task type specified\033[0m"
                show_task_types
                exit 1
            fi

            case "$(echo {{TASK_TYPE}} | tr '[:upper:]' '[:lower:]')" in
                l2taskbase)
                    TASK_TYPE="L2TaskBase"
                    ;;
                simpletaskbase)
                    TASK_TYPE="SimpleTaskBase"
                    ;;
                opcmtaskbase)
                    TASK_TYPE="OPCMTaskBase"
                    ;;
                *)
                    echo -e "\n\033[31mError: Invalid task type '{{TASK_TYPE}}'\033[0m"
                    show_task_types
                    exit 1
                    ;;
            esac
            echo -e "\nSelected task type: \033[33m $TASK_TYPE \033[0m"
            ./script/create-template.sh "$TASK_TYPE"
            ;;
        task)
            if [ -n "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: Task type should not be specified for 'task' command\033[0m"
                exit 1
            fi
            ./script/create-task.sh
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m"
            show_usage
            exit 1
            ;;
    esac

task COMMAND="" NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail

    echo -e "\033[42m                          \033[0m"
    echo -e "\033[42m    superchain-ops cli    \033[0m"
    echo -e "\033[42m                          \033[0m"

    if [ "{{COMMAND}}" = "" ]; then
        echo -e "\n\033[31mError: No command specified\033[0m\n"
        exit 1
    fi

    # shellcheck disable=SC2194
    case "{{COMMAND}}" in
        ls)
            echo ""
            ./script/sorted-tasks.sh {{NETWORK}}
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m\n"
            exit 1
            ;;
    esac

check-superchain-registry-latest:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    bash ${root_dir}/src/improvements/script/check-superchain-latest.sh

# This command simulates tasks in the example directory. There should be a corresponding task for each template.
simulate-all-templates:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    forge build
    simulation_count=0
    # When we spawn too many concurrent processes, the simulation fails with 'solc exited with signal: 9 (SIGKILL)'.
    # The batch size should be low enough to not cause issues, but high enough to not make the simulation too slow.
    batch_size=13
    current_batch=0

    # Collect PIDs of each background simulation.
    declare -a pids=()

    for task in "${root_dir}/test/tasks/example/"*/*; do
        if [ -d "$task" ]; then
            # Extract nested_safe_name with fail-safe default of foundation.
            nested_safe_name="foundation"
            if [ -f "$task/.env" ]; then
                # Check if NESTED_SAFE_NAME exists in the file and extract it
                if grep -q "NESTED_SAFE_NAME" "$task/.env"; then
                    extracted_value=$(grep "NESTED_SAFE_NAME" "$task/.env" | cut -d '=' -f 2)
                    # Only use the extracted value if its not empty and not null
                    if [ -n "$extracted_value" ] && [ "$extracted_value" != "null" ]; then
                        nested_safe_name="$extracted_value"
                    fi
                fi
            fi

            # Launch each simulation in background.
            "${root_dir}/src/improvements/script/simulate-task.sh" "$task" "$nested_safe_name" & pids+=( "$!" )
            current_batch=$((current_batch + 1))

            # If we have reached the batch size, wait for this batch to complete
            if [ $current_batch -eq $batch_size ]; then
                echo "Waiting for batch of $batch_size simulations to complete..."
                # Wait for current batch to finish
                for pid in "${pids[@]}"; do
                    wait "$pid"
                    simulation_count=$((simulation_count + 1))
                done
                
                # Reset for next batch
                pids=()
                current_batch=0
                echo "Batch completed. Starting next batch..."
            fi
        fi
    done

    # Wait for any remaining simulations in the final batch
    if [ ${#pids[@]} -gt 0 ]; then
        echo "Waiting for final batch of ${#pids[@]} simulations to complete..."
        for pid in "${pids[@]}"; do
            wait "$pid"
            simulation_count=$((simulation_count + 1))
        done
    fi

    echo "$simulation_count simulations run."

    # Count template files (excluding *.template.sol and boilerplate dir).
    template_count=$(find "${root_dir}/src/improvements/template" -type f ! -name "*.template.sol" ! -path "*/boilerplate/*" | wc -l | xargs)

    # Verify that every template file is referenced by at least one example task config.
    missing_templates=()
    while IFS= read -r template_file; do
        tmpl_name=$(basename "$template_file" .sol)
        if ! grep -R --quiet "templateName = \"${tmpl_name}\"" "${root_dir}/test/tasks/example"/*/*/config.toml 2>/dev/null; then
            missing_templates+=("$tmpl_name")
        fi
    done < <(find "${root_dir}/src/improvements/template" -type f ! -name "*.template.sol" ! -path "*/boilerplate/*")

    echo ""
    if [ ${#missing_templates[@]} -ne 0 ]; then
        echo -e "\033[31mError: The following template(s) do not have an example task referencing them:\033[0m" >&2
        for t in "${missing_templates[@]}"; do
            echo -e "\033[31m  • $t\033[0m" >&2
        done
        echo -e "\033[32mSuccess: All templates have a corresponding task.\033[0m"
        exit 1
    fi

simulate-stack NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"

    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m    superchain-ops stacked simulation    \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just simulate-stack <network> [task] [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Simulates the execution of tasks in a stacked manner, accounting for dependencies and nested safe architectures."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to simulate on (e.g. 'sep', 'eth')"
        echo
        echo "Optional arguments:"
        echo "  • [task]                       - Specific task to simulate (e.g. '001-task-name')"
        echo "                                   If omitted, simulates all non-terminal tasks for the network"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Examples:"
        echo "  just simulate-stack eth                             # Simulate all tasks for ethereum"
        echo "  just simulate-stack eth 001-example                # Simulate specific task on root safe"
        echo "  just simulate-stack eth 001-example foundation     # Simulate on foundation child safe"
        echo "  just simulate-stack eth 001-example council foundation  # Simulate on nested architecture"
        echo
        echo "Note: Stacked simulation executes all prerequisite non-terminal tasks in dependency order."
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    ETH_RPC_URL=$(just _fetch-rpc-url "{{NETWORK}}")

    echo -e "\n⏳ Stacked Task simulation in progress. This may take a while..."
    if [ -z "{{TASK}}" ]; then
        echo -e "⏳ You are simulating all tasks for network: {{NETWORK}}\n"
        just list-stack {{NETWORK}}
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string)" {{NETWORK}} --ffi --rpc-url $ETH_RPC_URL
    else
        child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
        child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")
        task_info="⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}'"
        if [ "$child_safe_depth_2" != "0x0000000000000000000000000000000000000000" ]; then
            task_info="$task_info on the nested safe: $child_safe_depth_2"
        else
            task_info="$task_info on the nested safe: $child_safe_depth_1"
        fi
        echo $task_info
        just list-stack {{NETWORK}} {{TASK}}
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_1" "$child_safe_depth_2" --ffi --rpc-url $ETH_RPC_URL
    fi
    echo -e "\n⚠️ Please note: Some Tenderly links may not work when running a stacked simulation. Check out Tenderly's Virtual TestNets as a workaround.⚠️"

sign NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="" HD_PATH="0":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    echo -e "\033[42m                                         \033[0m"
    echo -e "\033[42m       superchain-ops sign task          \033[0m"
    echo -e "\033[42m                                         \033[0m"

    show_usage() {
        echo
        echo "Usage: just sign <network> <task> [child-safe-name-depth-1] [child-safe-name-depth-2] [hd-path]"
        echo "Signs a task for execution on the specified network and safe architecture."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to sign for (e.g. 'sep', 'eth')"
        echo "  • <task>                       - The task to sign (e.g. '001-task-name')"
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo "  • [hd-path]                    - Hardware wallet derivation path (default: 0)"
        echo
        echo "Examples:"
        echo "  just sign eth 001-example                          # Sign for root safe only"
        echo "  just sign eth 001-example foundation               # Sign for foundation child safe"
        echo "  just sign eth 001-example council foundation       # Sign for council->foundation nested"
        echo
    }

    if [ -z "{{NETWORK}}" ] || [ -z "{{TASK}}" ]; then
        show_usage
        exit 0
    fi
    
    export SIGNING_MODE_IN_PROGRESS=true # This environment variable is typically used to reduce logging. TODO: Should consolidate this in the future.
    export STACKED_SIGNING_MODE=true # This environment variable is only ever set to true in this sign command. 

    ETH_RPC_URL=$(just --justfile "$root_just_file" _fetch-rpc-url "{{NETWORK}}")
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{NETWORK}}" "{{TASK}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")

    task_info="⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}'"
    if [ "$child_safe_depth_2" != "0x0000000000000000000000000000000000000000" ]; then
        task_info="$task_info on the nested safe: $child_safe_depth_2"
    else
        task_info="$task_info on the nested safe: $child_safe_depth_1"
    fi
    echo $task_info

    # We only support signing with ledger for now.
    signer_args=$(just --justfile "$root_just_file" _get-signer-args {{HD_PATH}})
    ${root_dir}/bin/eip712sign ${signer_args} -- \
     forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_2" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL

list-stack NETWORK="" TASK="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)

    show_usage() {
        echo
        echo "Usage: just list-stack <network> [task]"
        echo "This command will list all the tasks that can be simulated for a given network."
        echo "Available arguments:"
        echo "  • <network> - The network to simulate the stack for (e.g. 'sep', 'eth')"
        echo "  • [task]    - The task to simulate the stack for (e.g. '001-task-name')"
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    if [ -z "{{TASK}}" ]; then
        echo "Listing all tasks for network: {{NETWORK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string)" {{NETWORK}}
    else
        echo "Listing all tasks for network: {{NETWORK}} up to task: {{TASK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string,string)" {{NETWORK}} {{TASK}}
    fi

test:
    forge build
    forge test
    just simulate-all-templates


########################
### Helper functions ###
########################
# not intended for end users
_fetch-rpc-url NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail
    profile="${FOUNDRY_PROFILE:-default}"
    case "{{NETWORK}}" in
      sep)  yq eval ".profile.\"${profile}\".rpc_endpoints.sepolia" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      eth)  yq eval ".profile.\"${profile}\".rpc_endpoints.mainnet" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      *)    echo "Error: Must provide a valid network, '{{NETWORK}}' is not valid." >&2; exit 1 ;;
    esac

# Helper function to fetch the safe address for a given network and task.
[no-cd] 
_fetch-safe NETWORK TASK OWNER_SAFE_NAME:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    safe="0x0000000000000000000000000000000000000000" # Default to zero address for non-nested safes
    taskPath=${root_dir}/src/improvements/tasks/{{NETWORK}}/{{TASK}}
    if [ -n "{{OWNER_SAFE_NAME}}" ]; then
        safe=$(bash ${root_dir}/src/improvements/script/get-safe.sh $taskPath "{{OWNER_SAFE_NAME}}")
    fi
    echo "${safe}"

# Helper function to get the signer arguments for a given hdPath. We do not need to support signing with keystores.
[no-cd]
_get-signer-args hdPath='0':
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    hdpaths="m/44'/60'/{{hdPath}}'/0/0"
    signer=$(cast wallet address --ledger --mnemonic-derivation-path $hdpaths)
    signer_args="--ledger --hd-paths $hdpaths"
    echo $signer_args

export TASK_PATH := invocation_directory()
export ZERO_ADDRESS := "0x0000000000000000000000000000000000000000"
export signatures := env_var_or_default('SIGNATURES', '')

###################################
## Create a new template or task ##
## e.g. just new [template|task] ##
###################################
new COMMAND="" TASK_TYPE="":
    #!/usr/bin/env bash
    set -euo pipefail

    just _print-welcome-message

    show_usage() {
        echo
        echo "Usage: just new [template|task]"
        echo "Available commands:"
        echo "  • template  - Create a new template"
        echo "  • task      - Create a new task"
        echo
    }

    show_task_types() {
        echo
        echo "Available task types:"
        echo "  • l2taskbase - 'L2TaskBase' task type, these tasks require a superchain address registry and can iterate over multiple L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/test/tasks/mock/template/GasConfigTemplate.sol"
        echo "  • simpletaskbase - 'SimpleTaskBase' task type, these tasks require simple key value registry and are independent of the L2 chains"
        echo "    eg: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/FinanceTemplate.sol"
        echo "  • opcmtaskbase - 'OPCMTaskBase' task type, these tasks are used to make delegate calls to the Optimism Contracts Manager and are"
        echo "    dependent on the L2 chains and inherit from L2TaskBase"
        echo "    e.g.: https://github.com/ethereum-optimism/superchain-ops/blob/main/src/improvements/template/OPCMUpgradeV200.sol"
        echo
    }

    # shellcheck disable=SC2050
    case "{{COMMAND}}" in
        "")
            echo -e "\n\033[31mError: No command specified\033[0m"
            show_usage
            exit 1
            ;;
        template)
            if [ -z "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: No task type specified\033[0m"
                show_task_types
                exit 1
            fi

            case "$(echo {{TASK_TYPE}} | tr '[:upper:]' '[:lower:]')" in
                l2taskbase)
                    TASK_TYPE="L2TaskBase"
                    ;;
                simpletaskbase)
                    TASK_TYPE="SimpleTaskBase"
                    ;;
                opcmtaskbase)
                    TASK_TYPE="OPCMTaskBase"
                    ;;
                *)
                    echo -e "\n\033[31mError: Invalid task type '{{TASK_TYPE}}'\033[0m"
                    show_task_types
                    exit 1
                    ;;
            esac
            echo -e "\nSelected task type: \033[33m $TASK_TYPE \033[0m"
            ./script/create-template.sh "$TASK_TYPE"
            ;;
        task)
            if [ -n "{{TASK_TYPE}}" ]; then
                echo -e "\n\033[31mError: Task type should not be specified for 'task' command\033[0m"
                exit 1
            fi
            ./script/create-task.sh
            ;;
        *)
            echo -e "\n\033[31mError: Invalid command '{{COMMAND}}'\033[0m"
            show_usage
            exit 1
            ;;
    esac

#################################################
##                Stack Commands               ##
## e.g. simulate-stack, sign-stack, list-stack ##
#################################################
simulate-stack NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"

    just _print-welcome-message

    show_usage() {
        echo
        echo "Usage: just simulate-stack <network> [task] [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Simulates the execution of tasks in a stacked manner, accounting for dependencies and nested safe architectures."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to simulate on (e.g. 'sep', 'eth')"
        echo
        echo "Optional arguments:"
        echo "  • [task]                       - Specific task to simulate (e.g. '001-task-name')"
        echo "                                   If omitted, simulates all non-terminal tasks for the network"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Examples:"
        echo "  just simulate-stack eth                             # Simulate all tasks for ethereum"
        echo "  just simulate-stack eth 001-example                # Simulate specific task on root safe"
        echo "  just simulate-stack eth 001-example foundation     # Simulate on foundation child safe"
        echo "  just simulate-stack eth 001-example council foundation  # Simulate on nested architecture"
        echo
        echo "Note: Stacked simulation executes all prerequisite non-terminal tasks in dependency order."
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    ETH_RPC_URL=$(just _fetch-rpc-url "{{NETWORK}}")

    echo -e "\n⏳ Stacked Task simulation in progress. This may take a while..."
    if [ -z "{{TASK}}" ]; then
        echo -e "⏳ You are simulating all tasks for network: {{NETWORK}}\n"
        just list-stack {{NETWORK}}
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string)" {{NETWORK}} --ffi --rpc-url $ETH_RPC_URL
    elif [ -z "{{CHILD_SAFE_NAME_DEPTH_1}}" ] && [ -z "{{CHILD_SAFE_NAME_DEPTH_2}}" ]; then
        echo -e "⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}' on the root safe\n"
        just list-stack {{NETWORK}} {{TASK}}
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string)" "{{NETWORK}}" "{{TASK}}" --ffi --rpc-url $ETH_RPC_URL
    else
        task_dir_path="${root_dir}/src/improvements/tasks/{{NETWORK}}/{{TASK}}"
        child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "$task_dir_path" "{{CHILD_SAFE_NAME_DEPTH_1}}")
        child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "$task_dir_path" "{{CHILD_SAFE_NAME_DEPTH_2}}")
        just list-stack {{NETWORK}} {{TASK}}
        
        # Determine which function signature to use based on provided child safes
        if [ "$child_safe_depth_2" != "$ZERO_ADDRESS" ]; then
            echo -e "⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_2\n"
            forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_2" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
        else
            echo -e "⏳ You are simulating the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_1\n"
            forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
        fi
        
    fi
    echo -e "\n⚠️ Please note: Some Tenderly links may not work when running a stacked simulation. Check out Tenderly's Virtual TestNets as a workaround.⚠️"

sign-stack NETWORK="" TASK="" CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    just _print-welcome-message

    show_usage() {
        echo
        echo "Usage: just sign-stack <network> <task> [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Signs a task for execution on the specified network and safe architecture."
        echo
        echo "Required arguments:"
        echo "  • <network>                    - The network to sign for (e.g. 'sep', 'eth')"
        echo "  • <task>                       - The task to sign (e.g. '001-task-name')"
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Environment variables:"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo
        echo "Examples:"
        echo "  just sign-stack eth 001-example                          # Sign for root safe only"
        echo "  just sign-stack eth 001-example foundation               # Sign for foundation child safe"
        echo "  just sign-stack eth 001-example council foundation       # Sign for council->foundation nested"
        echo "  HD_PATH=1 just sign-stack eth 001-example                # Sign with HD path 1"
        echo
    }

    if [ -z "{{NETWORK}}" ] || [ -z "{{TASK}}" ]; then
        show_usage
        exit 0
    fi

    ETH_RPC_URL=$(just --justfile "$root_just_file" _fetch-rpc-url "{{NETWORK}}")
    task_dir_path="${root_dir}/src/improvements/tasks/{{NETWORK}}/{{TASK}}"
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "$task_dir_path" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "$task_dir_path" "{{CHILD_SAFE_NAME_DEPTH_2}}")

    # We only support signing with ledger for now.
    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
    USE_KEYSTORE=${USE_KEYSTORE:-} # Default to empty if not set
    
    # Get signer address and arguments using helper function
    signer_info=$(just --justfile "$root_just_file" _get-signer-args "$HD_PATH" "$USE_KEYSTORE")
    signer_args=$(echo "$signer_info" | sed -n '2p')

    export SIGNING_MODE_IN_PROGRESS=true # This environment variable is typically used to reduce logging. TODO: Should consolidate this in the future.
    export STACKED_SIGNING_MODE=true # This environment variable is only ever set to true in this sign command. 
    
    # Determine which function signature to use based on provided child safes
    if [ "$child_safe_depth_2" != "$ZERO_ADDRESS" ]; then
        echo -e "⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_2\n"
        ${root_dir}/bin/eip712sign ${signer_args} -- \
         forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_2" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
    elif [ -z "{{CHILD_SAFE_NAME_DEPTH_1}}" ] && [ -z "{{CHILD_SAFE_NAME_DEPTH_2}}" ]; then
        echo -e "⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}' on the root safe\n"
        just list-stack {{NETWORK}} {{TASK}}
        ${root_dir}/bin/eip712sign ${signer_args} -- \
         forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string)" "{{NETWORK}}" "{{TASK}}" --ffi --rpc-url $ETH_RPC_URL
    else
        echo -e "⏳ You are signing the task: {{TASK}} for network: '{{NETWORK}}' on the nested safe: $child_safe_depth_1\n"
        ${root_dir}/bin/eip712sign ${signer_args} -- \
         forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "simulateStack(string,string,address)" "{{NETWORK}}" "{{TASK}}" "$child_safe_depth_1" --ffi --rpc-url $ETH_RPC_URL
    fi
    echo -e "\n⚠️ Please note: Some Tenderly links may not work when running a stacked simulation. Check out Tenderly's Virtual TestNets as a workaround.⚠️"

list-stack NETWORK="" TASK="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)

    show_usage() {
        echo
        echo "Usage: just list-stack <network> [task]"
        echo "This command will list all the tasks that can be simulated for a given network."
        echo "Available arguments:"
        echo "  • <network> - The network to simulate the stack for (e.g. 'sep', 'eth')"
        echo "  • [task]    - The task to simulate the stack for (e.g. '001-task-name')"
        echo
    }

    # Check if network arg exists
    if [ -z "{{NETWORK}}" ]; then
        echo -e "\n\033[31mError: No network specified\033[0m"
        show_usage
        exit 1
    fi

    if [ -z "{{TASK}}" ]; then
        echo "Listing all tasks for network: {{NETWORK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string)" {{NETWORK}}
    else
        echo "Listing all tasks for network: {{NETWORK}} up to task: {{TASK}}"
        forge script ${root_dir}/src/improvements/tasks/StackedSimulator.sol:StackedSimulator --sig "listStack(string,string)" {{NETWORK}} {{TASK}}
    fi


#  ┌────────────────────┐      
#  │ Child Safe Depth 2 │
#  │ e.g. 'base-council'│
#  └────────────────────┘      
#             │                
#             └─────────────────┬
#                               ▼     
#                           ┌────────────────────┐
#                           │ Child Safe Depth 1 │
#                           │  e.g. 'foundation' │
#                           └────────────────────┘
#                                      │          
#                                      └──────────┬
#                                                 ▼
#                                          ┌─────────────────┐
#                                          │ ProxyAdminOwner │
#                                          └─────────────────┘
########################################
##          Non-Stacked Commands      ##
## e.g. simulate, sign                ##
########################################
simulate CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    config_path=${TASK_PATH}/config.toml
    script_name=$(yq '.templateName' ${config_path})

    just _print-welcome-message

    show_usage() {
        echo
        echo "Usage: just simulate [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Simulates a single task execution on the specified network and safe architecture."
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo
        echo "Environment variables:"
        echo "  • SIMULATE_WITHOUT_LEDGER      - If set, uses first safe owner instead of ledger"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo "  • FORK_BLOCK_NUMBER            - Specific block number to fork from (default: latest)"
        echo "                                   Set to -1 to use latest block explicitly"
        echo
    }

    # Make sure to set the FETCH_TASKS_TEST_DIR environment variable if we are running a test task. See: fetch-tasks.sh for more details.
    if [[ "$TASK_PATH" == *"test/tasks/example"* ]]; then
        export FETCH_TASKS_TEST_DIR="test/tasks/example"
    fi

    task_name=$(basename "$TASK_PATH")
    network=$(basename "$(dirname "$TASK_PATH")")
    ETH_RPC_URL=$(just _fetch-rpc-url "$network")

    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set

    # Get function signature and arguments using helper
    eval "$(just --justfile "$root_just_file" _build-simulate-args "$TASK_PATH" "$config_path" "{{CHILD_SAFE_NAME_DEPTH_1}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")"
    
    # Configure signer for simulation
    signer=$(just --justfile "$root_just_file" _get-simulation-signer "$config_path" "$ETH_RPC_URL" "$child_safe_depth_1" "$child_safe_depth_2")
    echo "signer: $signer"
    
    # Get fork block arguments
    fork_block_args=$(just --justfile "$root_just_file" _get-fork-block-args)
    
    echo -e "⏳ You are simulating the task: $task_name for network: '$network' on $target_safe\n"
    forge script ${script_name} --sig "$sig" "${args[@]}" --ffi --rpc-url $ETH_RPC_URL --sender ${signer} ${fork_block_args}

sign CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    config_path=${TASK_PATH}/config.toml
    script_name=$(yq '.templateName' ${config_path})
    
    just _print-welcome-message

    show_usage() {
        echo
        echo "Usage: just sign [child-safe-name-depth-1] [child-safe-name-depth-2]"
        echo "Signs a task for execution on the specified network and safe architecture."
        echo
        echo "Optional arguments:"
        echo "  • [child-safe-name-depth-1]    - Name of child safe at depth 1 (owned by root safe)"
        echo "                                   Examples: 'foundation', 'council', 'foundation-operations'"
        echo "  • [child-safe-name-depth-2]    - Name of child safe at depth 2 (owned by depth 1 safe)"
        echo "                                   Only used for deeply nested safe architectures e.g. Base"
        echo
        echo "Environment variables:"
        echo "  • HD_PATH                      - Hardware wallet derivation path (default: 0)"
        echo "  • USE_KEYSTORE                 - If set, uses keystore instead of ledger"
        echo
    }

    # Make sure to set the FETCH_TASKS_TEST_DIR environment variable if we are running a test task. See: fetch-tasks.sh for more details.
    if [[ "$TASK_PATH" == *"test/tasks/example"* ]]; then
        export FETCH_TASKS_TEST_DIR="test/tasks/example"
    fi
    export SIGNING_MODE_IN_PROGRESS=true

    task_name=$(basename "$TASK_PATH")
    network=$(basename "$(dirname "$TASK_PATH")")
    ETH_RPC_URL=$(just _fetch-rpc-url "$network")

    HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
    USE_KEYSTORE=${USE_KEYSTORE:-} # Default to empty if not set
    
    # Get function signature and arguments using helper
    eval "$(just --justfile "$root_just_file" _build-simulate-args "$TASK_PATH" "$config_path" "{{CHILD_SAFE_NAME_DEPTH_1}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")"
    
    # Get signer address and arguments using helper function
    signer_info=$(just --justfile "$root_just_file" _get-signer-args "$HD_PATH" "$USE_KEYSTORE")
    signer=$(echo "$signer_info" | sed -n '1p')
    signer_args=$(echo "$signer_info" | sed -n '2p')
    
    # Validate that signer is an owner on the target safe
    echo "Validating signer is an owner on the safe..."
    # forge script TaskManager --rpc-url $ETH_RPC_URL --sig "requireSignerOnSafe(address,address)" $signer $target_safe_for_validation
    
    echo "⏳ Task signing in progress. Some tasks take longer than others..."
    forge build
    ${root_dir}/bin/eip712sign ${signer_args} -- \
     forge script ${script_name} --sig "$sig" "${args[@]}" --ffi --rpc-url $ETH_RPC_URL

approve CHILD_SAFE_NAME_DEPTH_1="" CHILD_SAFE_NAME_DEPTH_2="":
  #!/usr/bin/env bash
  set -euo pipefail
  root_dir=$(git rev-parse --show-toplevel)
  root_just_file="${root_dir}/src/improvements/justfile"
  config_path=${TASK_PATH}/config.toml
  script_name=$(yq '.templateName' $config_path)
  
  # Build child safe array based on provided parameters
  child_safes=()
  if [ -n "{{CHILD_SAFE_NAME_DEPTH_1}}" ]; then
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "$TASK_PATH" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safes+=("$child_safe_depth_1")
    echo "Added child safe depth 1: $child_safe_depth_1"
  fi
  if [ -n "{{CHILD_SAFE_NAME_DEPTH_2}}" ]; then
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "$TASK_PATH" "{{CHILD_SAFE_NAME_DEPTH_2}}")
    child_safes+=("$child_safe_depth_2")
    echo "Added child safe depth 2: $child_safe_depth_2"
  fi

  # Calculate count and determine target safe
  count=${#child_safes[@]}
  
  if [ $count -eq 0 ]; then
    # No child safes - use empty array
    formatted_addresses="[]"
    echo "Using empty child safes array"
  else
    # Use the last (deepest) child safe as the target
    safe="${child_safes[$((count-1))]}"
    formatted_addresses=$(just --justfile "$root_just_file" _get-owner-addresses-string "$count" "$safe")
    echo "Using formatted addresses: $formatted_addresses"
  fi
  
  # Use environment variables for HD_PATH and USE_KEYSTORE
  HD_PATH=${HD_PATH:-0}  # Default to 0 if not set
  USE_KEYSTORE=${USE_KEYSTORE:-} # Default to empty if not set
  task_name=$(basename "$TASK_PATH")
  network=$(basename "$(dirname "$TASK_PATH")")
  ETH_RPC_URL=$(just _fetch-rpc-url "$network")
  echo "ETH_RPC_URL: $ETH_RPC_URL"
  
  # Configure signer (ledger or keystore)
  if [ -z "$USE_KEYSTORE" ]; then
    hdpaths="m/44'/60'/${HD_PATH}/0/0"
    echo "Using ledger with HD path: ${HD_PATH}"
    sender=$(cast wallet address --ledger --mnemonic-derivation-path "$hdpaths")
    signer_args="--ledger --hd-paths $hdpaths"
  else
    echo "Using keystore"
    signer_private_key=$(just --justfile="$root_just_file" _get-keystore-private-key)
    sender=$(cast wallet address --private-key ${signer_private_key})
    signer_args="--private-key ${signer_private_key#0x}"
  fi
  
  echo "Approving with sender: ${sender}"

  forge build
  forge script ${script_name} \
    --rpc-url ${ETH_RPC_URL} \
    --broadcast \
    --sender ${sender} \
    --sig "approve(string,address[],bytes)" \
    ${signer_args} \
    ${config_path} \
    ${formatted_addresses} \
    ${signatures}

########################
### Helper functions ###
########################
# not intended for end users
_fetch-rpc-url NETWORK="":
    #!/usr/bin/env bash
    set -euo pipefail
    profile="${FOUNDRY_PROFILE:-default}"
    case "{{NETWORK}}" in
      sep)  yq eval ".profile.\"${profile}\".rpc_endpoints.sepolia" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      eth)  yq eval ".profile.\"${profile}\".rpc_endpoints.mainnet" "$(git rev-parse --show-toplevel)/foundry.toml" ;;
      *)    echo "Error: Must provide a valid network, '{{NETWORK}}' is not valid." >&2; exit 1 ;;
    esac

# Helper function to fetch the safe address for a given network and task.
[no-cd] 
_fetch-safe TASK_DIR_PATH OWNER_SAFE_NAME:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    safe="$ZERO_ADDRESS" # Default to zero address for non-nested safes
    if [ -n "{{OWNER_SAFE_NAME}}" ]; then
        safe=$(bash ${root_dir}/src/improvements/script/get-safe.sh "{{TASK_DIR_PATH}}" "{{OWNER_SAFE_NAME}}")
    fi
    echo "${safe}"

# Helper function to get the signer address and arguments. Supports both ledger and keystore configurations.
# Returns two lines: first line is signer address, second line is signer arguments
[no-cd]
_get-signer-args hdPath='0' use_keystore_flag='':
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    # Configure signer (ledger or keystore)
    if [ -z "{{use_keystore_flag}}" ]; then
        hdpaths="m/44'/60'/{{hdPath}}'/0/0"
        echo "Using ledger" >&2
        signer=$(cast wallet address --ledger --mnemonic-derivation-path $hdpaths)
        signer_args="--ledger --hd-paths $hdpaths"
    else
        echo "Using keystore" >&2
        signer_private_key=$(just --justfile "$root_just_file" _get-keystore-private-key)
        signer=$(cast wallet address --private-key ${signer_private_key})
        signer_args="--private-key ${signer_private_key#0x}"
    fi
    
    echo "Signing with: ${signer}" >&2
    echo "${signer}"
    echo "${signer_args}"

# Helper function to get fork block arguments based on FORK_BLOCK_NUMBER environment variable
[no-cd]
_get-fork-block-args:
    #!/usr/bin/env bash
    set -euo pipefail
    
    # Allow simulating from a specific block by setting FORK_BLOCK_NUMBER environment variable.
    # If not set (or set to -1), default to using the latest block.
    if [ "${FORK_BLOCK_NUMBER:-"-1"}" = "-1" ]; then
        echo ""  # Return empty string for no additional args
    else
        echo "Using fork block number from env: ${FORK_BLOCK_NUMBER}" >&2
        echo "--fork-block-number ${FORK_BLOCK_NUMBER}"
    fi

# Helper function to configure signer for simulation (ledger or safe owner)
[no-cd]
_get-simulation-signer CONFIG_PATH ETH_RPC_URL CHILD_SAFE_DEPTH_1 CHILD_SAFE_DEPTH_2:
    #!/usr/bin/env bash
    set -euo pipefail
    HD_PATH=${HD_PATH:-0}
    
    # Configure signer for simulation
    if [ -z "${SIMULATE_WITHOUT_LEDGER:-}" ]; then
        signer=$(cast wallet address --ledger --mnemonic-derivation-path "m/44'/60'/${HD_PATH}'/0/0")
        echo "Simulating with ledger account: ${signer}" >&2
    else
        # Get the appropriate safe to extract signer from
        if [ "{{CHILD_SAFE_DEPTH_2}}" != "$ZERO_ADDRESS" ]; then
            safe_for_signer="{{CHILD_SAFE_DEPTH_2}}"
        elif [ "{{CHILD_SAFE_DEPTH_1}}" != "$ZERO_ADDRESS" ]; then
            safe_for_signer="{{CHILD_SAFE_DEPTH_1}}" 
        else
            safe_for_signer=$(forge script TaskManager --sig "getRootSafe(string)" "{{CONFIG_PATH}}" --rpc-url "{{ETH_RPC_URL}}" --json | jq -r '.returns["0"].value')
        fi
        signer=$(cast call ${safe_for_signer} "getOwners()(address[])" -r "{{ETH_RPC_URL}}" | grep -oE '0x[a-fA-F0-9]{40}' | head -n1)
        echo "Simulating without ledger using first owner from safe ${safe_for_signer}: ${signer}" >&2
    fi
    
    echo "${signer}"

# Helper function to handle keystore selection and private key extraction
[no-cd]
_get-keystore-private-key:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    
    echo "Enter your foundry keystore path (e.g. ~/.foundry/keystores/sep-test-private-key):" >&2
    keystorePath=$(cd ~/.foundry/keystores/ && fzf --header="Searching your keystore in $PWD" --prompt="Keystore for signing:")
    
    echo "Keystore path: ${keystorePath}" >&2
    # Build full keystore path
    full_keystore_path="$HOME/.foundry/keystores/${keystorePath}"
    signer_private_key=$(cast wallet pk --keystore ${full_keystore_path})
    sender=$(cast wallet address --private-key ${signer_private_key})
    echo "Signing with the signer: ${sender}" >&2
    if [ -z "${signer_private_key}" ]; then
        echo "Error: Failed to get private key for keystore ${full_keystore_path}" >&2
        exit 1
    fi
    echo "${signer_private_key}"

# Helper function to build simulator function signature and arguments. It's expected that the caller will eval the output.
[no-cd]
_build-simulate-args TASK_DIR_PATH CONFIG_PATH CHILD_SAFE_NAME_DEPTH_1 CHILD_SAFE_NAME_DEPTH_2:
    #!/usr/bin/env bash
    set -euo pipefail
    root_dir=$(git rev-parse --show-toplevel)
    root_just_file="${root_dir}/src/improvements/justfile"
    
    child_safe_depth_1=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_DIR_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_1}}")
    child_safe_depth_2=$(just --justfile "$root_just_file" _fetch-safe "{{TASK_DIR_PATH}}" "{{CHILD_SAFE_NAME_DEPTH_2}}")
    task_name=$(basename "{{TASK_DIR_PATH}}")
    
    # Export child safe addresses for use by caller
    echo "child_safe_depth_1=\"$child_safe_depth_1\""
    echo "child_safe_depth_2=\"$child_safe_depth_2\""
    
    # Build function signature and arguments dynamically
    if [ "$child_safe_depth_2" != "$ZERO_ADDRESS" ]; then
        echo "sig=\"simulate(string,address,address)\""
        echo "args=(\"{{CONFIG_PATH}}\" \"$child_safe_depth_2\" \"$child_safe_depth_1\")"
        echo "target_safe=\"nested safe: $child_safe_depth_2\""
    elif [ "$child_safe_depth_1" != "$ZERO_ADDRESS" ]; then
        echo "sig=\"simulate(string,address)\""
        echo "args=(\"{{CONFIG_PATH}}\" \"$child_safe_depth_1\")"
        echo "target_safe=\"nested safe: $child_safe_depth_1\""
    else 
        echo "sig=\"simulate(string)\""
        echo "args=(\"{{CONFIG_PATH}}\")"
        echo "target_safe=\"default safes\""
    fi

[no-cd]
_print-welcome-message:
    #!/usr/bin/env bash
    set -euo pipefail
    echo -e "\033[42m                              \033[0m"
    echo -e "\033[42m        superchain-ops        \033[0m"
    echo -e "\033[42m                              \033[0m"

# Helper function to get the owner addresses string for a given count and safe address.
[no-cd]
_get-owner-addresses-string COUNT SAFE_ADDRESS:
    #!/usr/bin/env bash
    set -euo pipefail
    
    owner_addresses=()
    if (( {{COUNT}} > 1 )); then
      for i in $(seq 1 $(({{COUNT}}-1))); do
          owner_addresses+=("0x0000000000000000000000000000000000000000")
      done
    fi
    owner_addresses+=("{{SAFE_ADDRESS}}")
    
    # Format the bash array into JSON format for forge script
    if [ ${#owner_addresses[@]} -eq 0 ]; then
        echo "[]"
    else
        # Build JSON array: ["0x123...", "0x456..."]
        formatted_addresses="["
        for i in "${!owner_addresses[@]}"; do
            if [ $i -gt 0 ]; then
                formatted_addresses+=","
            fi
            formatted_addresses+="\"${owner_addresses[$i]}\""
        done
        formatted_addresses+="]"
        echo "$formatted_addresses"
    fi